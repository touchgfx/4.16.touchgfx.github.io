"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[7124],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=p(n),m=r,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||o;return n?a.createElement(h,l(l({ref:t},d),{},{components:n})):a.createElement(h,l({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,l=new Array(o);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:r,l[1]=i;for(var p=2;p<o;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},22425:function(e,t,n){var a=n(67294);class r extends a.Component{render(){return a.createElement("div",{class:"code-header"},a.createElement("div",null,a.createElement("h5",null,this.props.children)))}}t.Z=r},44035:function(e,t,n){var a=n(67294),r=n(25026);t.Z=function(e){const t=e.noShadow||!1,n=e.width,o=e.height,l=(0,r.Z)(e.imageSource);return t?a.createElement("div",{class:"figure noshadow"},a.createElement("a",{href:l,target:"_blank"},a.createElement("img",{width:n,height:o,src:l})),a.createElement("p",null,e.children)):a.createElement("div",{class:"figure"},a.createElement("a",{href:l,target:"_blank"},a.createElement("img",{width:n,height:o,src:l})),a.createElement("p",null,e.children))}},28810:function(e,t,n){n.r(t),n.d(t,{assets:function(){return x},contentTitle:function(){return f},default:function(){return _},frontMatter:function(){return h},metadata:function(){return g},toc:function(){return y}});var a=n(3905),r=n(44035),o=n(22425),l=Object.defineProperty,i=Object.defineProperties,s=Object.getOwnPropertyDescriptors,p=Object.getOwnPropertySymbols,d=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,u=(e,t,n)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,m=(e,t)=>{for(var n in t||(t={}))d.call(t,n)&&u(e,n,t[n]);if(p)for(var n of p(t))c.call(t,n)&&u(e,n,t[n]);return e};const h={id:"fonts-in-unmapped-flash",title:"Using Non-Memory Mapped Flash for Font Data"},f=void 0,g={unversionedId:"development/scenarios/fonts-in-unmapped-flash",id:"development/scenarios/fonts-in-unmapped-flash",title:"Using Non-Memory Mapped Flash for Font Data",description:"",source:"@site/i18n/ja/docusaurus-plugin-content-docs/current/development/scenarios/fonts-in-unmapped-flash.mdx",sourceDirName:"development/scenarios",slug:"/development/scenarios/fonts-in-unmapped-flash",permalink:"/4.16/ja/docs/development/scenarios/fonts-in-unmapped-flash",draft:!1,tags:[],version:"current",frontMatter:{id:"fonts-in-unmapped-flash",title:"Using Non-Memory Mapped Flash for Font Data"},sidebar:"docs",previous:{title:"Using Serial Flash for images and fonts",permalink:"/4.16/ja/docs/development/scenarios/using-serial-flash"},next:{title:"Changing the Pixel Format of an Application",permalink:"/4.16/ja/docs/development/scenarios/scenarios-change-pixelformat-bpp"}},x={},y=[{value:"Font Layouts",id:"font-layouts",level:2},{value:"Mapped Storage Format",id:"mapped-storage-format",level:3},{value:"Unmapped Storage Format",id:"unmapped-storage-format",level:3},{value:"Example",id:"example",level:2},{value:"Linker Script Modifications",id:"linker-script-modifications",level:3}],b={toc:y};function _(e){var t,n=e,{components:l}=n,u=((e,t)=>{var n={};for(var a in e)d.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&p)for(var a of p(e))t.indexOf(a)<0&&c.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=m(m({},b),u),i(t,s({components:l,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"In this section we will discuss how to use a new font-layout that will allow you to put almost all font data into unmapped external flash. The effect is that you can have many thousand letters in an application using only 50 kb of flash."),(0,a.kt)("h2",m({},{id:"font-layouts"}),"Font Layouts"),(0,a.kt)("p",null,"TouchGFX supports two different font layouts for the fonts compiled into your application. The layout used is selected in TouchGFX Designer in the configurations tab:"),(0,a.kt)(r.Z,{imageSource:"/img/development/ui-development/scenarios/fonts-in-unmapped-flash/designer-configuration.webp",mdxType:"Figure"},"Configurating font layout"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Mapped storage format")," is the default font layout and should be used on systems where fonts are stored in memory mapped flash (internal or e.g. external QSPI flash)."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"Unmapped storage format")," is the new font layout. It allows most of the font data to be stored in unmapped flash. This will typically be a SPI-flash, but can be any type of storage."),(0,a.kt)("h3",m({},{id:"mapped-storage-format"}),"Mapped Storage Format"),(0,a.kt)("p",null,"The mapped storage format keeps the font data in two tables."),(0,a.kt)("p",null,"The first table is an array of ",(0,a.kt)("em",{parentName:"p"},"touchgfx::GlyphNode"),". These contain the properties of the individual characters: height, width, unicode, and similar."),(0,a.kt)(o.Z,{mdxType:"CodeHeader"},"generated/fonts/src/Table_verdana_20_4bpp.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",m({parentName:"pre"},{className:"language-cpp"}),"FONT_TABLE_LOCATION_FLASH_PRAGMA\nKEEP extern const touchgfx::GlyphNode glyphs_verdana_20_4bpp[] FONT_TABLE_LOCATION_FLASH_ATTRIBUTE =\n{\n    {     0, 0x0020,   0,   0,   0,   0,   7,   0,   0, 0x00 },\n    {     0, 0x002C,   5,   7,   3,   1,   7,   0,   2, 0x00 },\n    {    21, 0x0030,  11,  14,  14,   1,  13,   0,   0, 0x00 },\n    {   105, 0x0032,  11,  14,  14,   1,  13,   0,   0, 0x00 },\n    {   189, 0x0033,  11,  14,  14,   1,  13,   0,   0, 0x00 },\n    {   273, 0x0034,  12,  14,  14,   0,  13,   0,   0, 0x00 },\n    ...\n}\n")),(0,a.kt)("p",null,"The second table (split in multiple files for large fonts) contains the pixel-patterns for the characters."),(0,a.kt)(o.Z,{mdxType:"CodeHeader"},"generated/fonts/src/Font_verdana_20_4bpp_0.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",m({parentName:"pre"},{className:"language-cpp"}),"FONT_GLYPH_LOCATION_FLASH_PRAGMA\nKEEP extern const uint8_t unicodes_verdana_20_4bpp_0[] FONT_GLYPH_LOCATION_FLASH_ATTRIBUTE =\n{\n    // Unicode: [0x0020]\n    // (Has no glyph data)\n    // Unicode: [0x002C]\n    0x00, 0x87, 0x04, 0x20, 0xFF, 0x03, 0x60, 0xBF, 0x00, 0xA0, 0x5F, 0x00, 0xE0, 0x0D, 0x00, 0xF3,\n    0x07, 0x00, 0xF6, 0x01, 0x00,\n    // Unicode: [0x0030]\n    0x00, 0xA3, 0xFE, 0x9D, 0x01, 0x00, 0x40, 0xFF, 0x9B, 0xFC, 0x1D, 0x00, 0xD0, 0x4F, 0x00, 0x80,\n    0x9F, 0x00, 0xF3, 0x0B, 0x00, 0x10, 0xEE, 0x00, 0xF7, 0x07, 0x00, 0x00, 0xFB, 0x03, 0xF9, 0x06,\n    ...\n}\n")),(0,a.kt)("p",null,"The GlyphNodes will be used by the TouchGFX engine during text layout. The pixels will be read by the DMA2D or software routines during drawing."),(0,a.kt)("p",null,"On platforms using the normal LCD classes, e.g. LCD16Bpp or LCD24Bpp, these tables must be stored in internal flash or memory mapped external flash."),(0,a.kt)("p",null,"On platforms using a unmapped external flash, the LCD16BppSerialFlash can read the pixels-patterns from unmapped serial flash, but the GlyphNodes must be in internal flash."),(0,a.kt)("h3",m({},{id:"unmapped-storage-format"}),"Unmapped Storage Format"),(0,a.kt)("p",null,"The unmapped storage format splits the font data in three tables. The two tables from the mapped storage layout is reused, but a third table is added:"),(0,a.kt)(o.Z,{mdxType:"CodeHeader"},"generated/fonts/src/Table_verdana_20_4bpp.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",m({parentName:"pre"},{className:"language-cpp"}),"FONT_SEARCHTABLE_LOCATION_FLASH_PRAGMA\nKEEP extern const uint16_t unicodelist_verdana_20_4bpp[] FONT_SEARCHTABLE_LOCATION_FLASH_ATTRIBUTE =\n{\n    0x0020,\n    0x002E,\n    0x003F,\n    0x004E,\n    0x0054,\n    ....\n}\n")),(0,a.kt)("p",null,"This third table just contains the unicodes present in the font."),(0,a.kt)("p",null,"When this font layout is used, the third table must be present in internal flash, but the other two tables can be moved to external flash. This is a considerable saving, as the third table uses two bytes for each character, whereas the GlyphNode table uses 14 bytes. This reduces the storage requirement in internal flash."),(0,a.kt)("p",null,"When the font data is placed in unmapped flash, the mcu cannot access it directly. We therefore have to provide a flash reader object to the font subsystem.",(0,a.kt)("br",{parentName:"p"}),"\n","The code for this is automatically generated by TouchGFXGenerator:"),(0,a.kt)(o.Z,{mdxType:"CodeHeader"},"TouchGFXConfiguration.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",m({parentName:"pre"},{className:"language-cpp",metastring:"{12-12}","{12-12}":!0}),"static TouchGFXDataReader dataReader;\nstatic LCD16bppSerialFlash display(dataReader);\nstatic ApplicationFontProvider fontProvider;\nstatic Texts texts;\nstatic TouchGFXHAL hal(dma, display, tc, 240, 320);\nvoid touchgfx_init()\n{\n  Bitmap::registerBitmapDatabase(BitmapDatabase::getInstance(), BitmapDatabase::getInstanceSize());\n  TypedText::registerTexts(&texts);\n  Texts::setLanguage(0);\n  hal.setDataReader(&dataReader);\n  fontProvider.setFlashReader(&dataReader);\n...\n")),(0,a.kt)("p",null,"If you are not using the generator, you must do this manually."),(0,a.kt)("p",null,"Remember to implement the functions in ",(0,a.kt)("em",{parentName:"p"},"TouchGFXDataReader")," so data is actually read from your flash."),(0,a.kt)("h2",m({},{id:"example"}),"Example"),(0,a.kt)("p",null,"Below is a screenshot of an application using the new font layout:"),(0,a.kt)(r.Z,{imageSource:"/img/development/ui-development/scenarios/fonts-in-unmapped-flash/example1.webp",mdxType:"Figure"},"Example application with 4000 Chinese characters"),(0,a.kt)("p",null,"This application runs on a STM32G071 Nucleo board with a MB1642A display module:"),(0,a.kt)(r.Z,{imageSource:"/img/development/ui-development/scenarios/fonts-in-unmapped-flash/g071.webp",width:"400",mdxType:"Figure"},"Example application running on STM32G071Nucleo"),(0,a.kt)("p",null,"In this application we have 4000 Chinese characters in size 20, 4 bits pr pixel. The application and data takes up 61Kb of 128 Kb available on the STM32G071. The font data is distributed as follows (excluding minor objects):"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",m({parentName:"tr"},{align:null}),"Table"),(0,a.kt)("th",m({parentName:"tr"},{align:null}),"Location"),(0,a.kt)("th",m({parentName:"tr"},{align:null}),"Size"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",m({parentName:"tr"},{align:null}),"GlyphNodes"),(0,a.kt)("td",m({parentName:"tr"},{align:null}),"External SPI flash"),(0,a.kt)("td",m({parentName:"tr"},{align:null}),"57.372 bytes")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",m({parentName:"tr"},{align:null}),"Pixel patterns"),(0,a.kt)("td",m({parentName:"tr"},{align:null}),"External SPI flash"),(0,a.kt)("td",m({parentName:"tr"},{align:null}),"3.116.296 bytes")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",m({parentName:"tr"},{align:null}),"Unicode list"),(0,a.kt)("td",m({parentName:"tr"},{align:null}),"Internal flash"),(0,a.kt)("td",m({parentName:"tr"},{align:null}),"8.000 bytes")))),(0,a.kt)("h3",m({},{id:"linker-script-modifications"}),"Linker Script Modifications"),(0,a.kt)("p",null,"To use the unmapped font layout correctly, you must update your linker script to place the tables correctly."),(0,a.kt)(o.Z,{mdxType:"CodeHeader"},"STM32F746.ld"),(0,a.kt)("pre",null,(0,a.kt)("code",m({parentName:"pre"},{}),"define symbol __ICFEDIT_region_ROM_start__ = 0x08000000;\ndefine symbol __ICFEDIT_region_ROM_end__   = 0x0801FFFF;\ndefine symbol __ICFEDIT_region_RAM_start__ = 0x20000000;\ndefine symbol __ICFEDIT_region_RAM_end__   = 0x20008FFF;\ndefine symbol __ICFEDIT_region_SERIAL_FLASH_start__ = 0x90000000;\ndefine symbol __ICFEDIT_region_SERIAL_FLASH_end__   = 0x91000000;\n\nplace in ROM_region   { readonly };\nplace in RAM_region   { readwrite,\n                        block CSTACK, block HEAP };\n\nplace in SERIAL_FLASH_region {section ExtFlashSection, section FontFlashSection };\n")),(0,a.kt)("p",null,"In this linker script we put both the ExtFlashSection (images and font pixels) and FontFlashSection (the GlyphNodes) in the external flash. Any other read-only data is in the internal flash (ROM_region)."))}_.isMDXComponent=!0}}]);