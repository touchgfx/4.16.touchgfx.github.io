"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[4475],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return d}});var r=a(67294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),f=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=f(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=f(a),m=n,d=u["".concat(s,".").concat(m)]||u[m]||c[m]||l;return a?r.createElement(d,i(i({ref:t},p),{},{components:a})):r.createElement(d,i({ref:t},p))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:n,i[1]=o;for(var f=2;f<l;f++)i[f]=a[f];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},22425:function(e,t,a){var r=a(67294);class n extends r.Component{render(){return r.createElement("div",{class:"code-header"},r.createElement("div",null,r.createElement("h5",null,this.props.children)))}}t.Z=n},44035:function(e,t,a){var r=a(67294),n=a(25026);t.Z=function(e){const t=e.noShadow||!1,a=e.width,l=e.height,i=(0,n.Z)(e.imageSource);return t?r.createElement("div",{class:"figure noshadow"},r.createElement("a",{href:i,target:"_blank"},r.createElement("img",{width:a,height:l,src:i})),r.createElement("p",null,e.children)):r.createElement("div",{class:"figure"},r.createElement("a",{href:i,target:"_blank"},r.createElement("img",{width:a,height:l,src:i})),r.createElement("p",null,e.children))}},6771:function(e,t,a){var r=a(67294);class n extends r.Component{render(){return r.createElement("p",null,r.createElement("div",{class:"videoWrapper"},r.createElement("video",{controls:!0},r.createElement("source",{src:this.props.url,type:"video/mp4"}))))}}t.Z=n},4680:function(e,t,a){a.r(t),a.d(t,{assets:function(){return y},contentTitle:function(){return g},default:function(){return w},frontMatter:function(){return h},metadata:function(){return k},toc:function(){return b}});var r=a(3905),n=a(44035),l=a(22425),i=a(6771),o=Object.defineProperty,s=Object.defineProperties,f=Object.getOwnPropertyDescriptors,p=Object.getOwnPropertySymbols,u=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,m=(e,t,a)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):e[t]=a,d=(e,t)=>{for(var a in t||(t={}))u.call(t,a)&&m(e,a,t[a]);if(p)for(var a of p(t))c.call(t,a)&&m(e,a,t[a]);return e};const h={id:"lowering-memory-usage-with-partial-framebuffer",title:"Lowering Memory Usage with Partial Framebuffer"},g=void 0,k={unversionedId:"development/scenarios/lowering-memory-usage-with-partial-framebuffer",id:"development/scenarios/lowering-memory-usage-with-partial-framebuffer",title:"Lowering Memory Usage with Partial Framebuffer",description:"",source:"@site/i18n/ko/docusaurus-plugin-content-docs/current/development/scenarios/lowering-memory-usage-with-partial-framebuffer.mdx",sourceDirName:"development/scenarios",slug:"/development/scenarios/lowering-memory-usage-with-partial-framebuffer",permalink:"/4.16/ko/docs/development/scenarios/lowering-memory-usage-with-partial-framebuffer",draft:!1,tags:[],version:"current",frontMatter:{id:"lowering-memory-usage-with-partial-framebuffer",title:"Lowering Memory Usage with Partial Framebuffer"},sidebar:"docs",previous:{title:"TouchGFX on Low Cost Hardware",permalink:"/4.16/ko/docs/development/scenarios/touchgfx-on-lowcost-hardware"},next:{title:"Using Non-Memory Mapped Flash for Storing Images",permalink:"/4.16/ko/docs/development/scenarios/using-non-memory-mapped-flash"}},y={},b=[{value:"Full-size Frame Buffer Memory",id:"full-size-frame-buffer-memory",level:2},{value:"Partial Frame Buffer Memory",id:"partial-frame-buffer-memory",level:2},{value:"Display Tearing",id:"display-tearing",level:2},{value:"Display Update Example",id:"display-update-example",level:2},{value:"Configuring Partial Frame Buffers",id:"configuring-partial-frame-buffers",level:2},{value:"Transferring Frame Buffers to the Screen",id:"transferring-frame-buffers-to-the-screen",level:2},{value:"Transferring Frame Buffers to the STM32G081 SPI Display",id:"transferring-frame-buffers-to-the-stm32g081-spi-display",level:3},{value:"Transferring Frame Buffers to the X-NUCLEO-GFX01M1 SPI Display",id:"transferring-frame-buffers-to-the-x-nucleo-gfx01m1-spi-display",level:3},{value:"Transferring Frame Buffers on DSI Display",id:"transferring-frame-buffers-on-dsi-display",level:3},{value:"Transferring Frame Buffers on SPI Display",id:"transferring-frame-buffers-on-spi-display",level:3},{value:"\uacb0\ub860",id:"conclusion",level:2}],T={toc:b};function w(e){var t,a=e,{components:o}=a,m=((e,t)=>{var a={};for(var r in e)u.call(e,r)&&t.indexOf(r)<0&&(a[r]=e[r]);if(null!=e&&p)for(var r of p(e))t.indexOf(r)<0&&c.call(e,r)&&(a[r]=e[r]);return a})(a,["components"]);return(0,r.kt)("wrapper",(t=d(d({},T),m),s(t,f({components:o,mdxType:"MDXLayout"}))),(0,r.kt)("p",null,"This section explains, by exemplifying with a clock application, how to configure and use Partial Frame Buffers, to lower memory requirements at the expense of some performance."),(0,r.kt)("p",null,"A video of the application running on the STM32L4R9Discovery evaluation kit can be seen below"),(0,r.kt)(i.Z,{url:"http://sw-center-st-com.s3-eu-west-1.amazonaws.com/touchgfx/TouchGFX/knowledgebase/Partial%20framebuffer/Partial%20framebuffer.mp4",mdxType:"Video"}),(0,r.kt)("h2",d({},{id:"full-size-frame-buffer-memory"}),"Full-size Frame Buffer Memory"),(0,r.kt)("p",null,"Normally, your frame buffer is a big memory array with enough memory to hold all the pixels available on your display. If you are running on a 24-bit display with a resolution of 480 x 272, a full-size frame buffer holds 480 x 272 x 3 bytes = 391.680 bytes."),(0,r.kt)("p",null,'Some applications may have 2- ("Double buffering") or even 3 frame buffers. The total memory requirement in these cases would then be 783.360 and 1.175.040 bytes.'),(0,r.kt)("p",null,"TouchGFX writes pixel values to the frame buffer when drawing any part of the UI, after all drawing operations have completed, the frame buffer is transferred to the display. Typically, the whole frame buffer is transferred to the display even if only a part of the UI is updated. Generally, the framebuffer can be updated in many small blocks before itis transferred."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Update1, Update 2, Update 3, ..., Update N, Transfer to display")),(0,r.kt)("p",null,"In some cases, particularly in low cost solutions with no external RAM, frame buffers are required to be small enough to allow the rest of the application to fit in the internal RAM together with the framebuffer. This is where partial frame buffers are useful."),(0,r.kt)("h2",d({},{id:"partial-frame-buffer-memory"}),"Partial Frame Buffer Memory"),(0,r.kt)("p",null,"Partial frame buffers allows a TouchGFX application to run on top of a few, less than full-size frame buffers. The number and size of the frame buffers are configurable. This technique can lower the memory requirements of an application by a substantial amount, but comes with some limitations:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Partial frame buffers will only work on displays that have built-in memory. These are typically DSI displays or displays with a parallel bus connection (DBI type A/B, 8080/6800) or SPI-bus connection."),(0,r.kt)("li",{parentName:"ul"},"Potential tearing for complex applications.")),(0,r.kt)("p",null,"Rather than using a frame buffer representing every pixel on the display, partial frame buffers typically cover a smaller part. In the clock example used in this article, three frame buffers of 11.700 bytes each are used. This results in a memory footprint for frame buffers of 35.100 bytes."),(0,r.kt)("p",null,"Whenever the application needs to update a part of the UI, TouchGFX will select one of the configured, partial frame buffers, complete its drawing operation in the partial framebuffer, and transfer that part to the display. This is repeated for all areas of the UI that need to be rendered - This changes the formula for updating and transferring data to:"),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Update1, Transfer1, Update2, Transfer2, Update3, Transfer3, ..., UpdateN, TransferN")),(0,r.kt)("p",null,"In some cases the transfer of one partial frame buffer can run while the update of the next buffer is running."),(0,r.kt)("h2",d({},{id:"display-tearing"}),"Display Tearing"),(0,r.kt)("p",null,"Contrary to using full-size frame buffers, TouchGFX will transfer parts of the UI as soon as they are updated, when using partial frame buffers. The display will show the received updates on its glass after at most 16 ms (for 60 fps displays) because the display needs to be refreshed regularly. Because of this, the first updates to the display can potentially be visible to the user before all updates have been transferred."),(0,r.kt)("p",null,"If the total sequence of draw operations and transfers take a long time to complete ( > 16 ms) it is highly possible that the user will see a combination of the previous frame and some of the new updates. This is called display tearing and is not desirable. For this reason, partial frame buffers are not suitable for applications that make use of complex animations that take a long time to render."),(0,r.kt)("h2",d({},{id:"display-update-example"}),"Display Update Example"),(0,r.kt)("p",null,"Before we get into how to configure partial frame buffers in your application let's have a look at a concrete example showing a digital clock with a moving circle arc representing seconds. The green circle arc is moving 6 degrees each second and does a full rotation in a minute. The UI is built from four Widgets as seen in the image below:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",d({parentName:"li"},{href:"../ui-development/ui-components/shapes/line"}),"Line")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",d({parentName:"li"},{href:"../ui-development/ui-components/shapes/circle"}),"Circle")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",d({parentName:"li"},{href:"../ui-development/ui-components/miscellaneous/digital-clock"}),"Digital Clock")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",d({parentName:"li"},{href:"../ui-development/ui-components/shapes/box"}),"Box"))),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/touchgfx-designer-with-widgets.webp",mdxType:"Figure"}),(0,r.kt)("p",null,"Here is the code that updates the digital clock and circle arc:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"MainView.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{21-25}","{21-25}":!0}),"void MainView::handleTickEvent()\n{\n  ticks++;\n  if (ticks == 10)\n  {\n      ticks = 0;\n      secs += 1;\n      if (secs == 60)  //increment minutes\n      {\n        secs = 0;\n        min += 1;\n        if (min == 60) //increment hours\n        {\n          min = 0;\n          hour += 1;\n          if (hour == 24)\n          {\n            hour = 0;\n          }\n        }\n        //Only update digital clock when minutes or hours change\n        digitalClock.setTime24Hour(hour, min, secs);\n      }\n    //Always update seconds\n    circleSeconds.updateArc(secs*6 - 20, secs*6);\n  }\n}\n")),(0,r.kt)("p",null,"The following images shows the areas that are updated in the first few seconds when the circle arc approaches the top and digital clock is updated (the grey rectangles). In the first two frames, only the seconds are changing (58 and 59 seconds). In the thirs the seconds reaches 60 and the hour and minutes text is updated:"),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/simulator-updated-areas-1.webp",mdxType:"Figure"}),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/simulator-updated-areas-2.webp",mdxType:"Figure"}),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/simulator-updated-areas-3.webp",mdxType:"Figure"}),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/simulator-updated-areas-4.webp",mdxType:"Figure"}),(0,r.kt)("p",null,"The rectangles updated in the third image above are 154 x 60 pixels, 20 x 12 pixels, and 33 x 8 pixels. When using standard frame buffers these three rectangles would be drawn into the full frame buffer (overwriting the previous pixels), which would afterwards be transferred to the display. When using partial frame buffers, these three rectangles would be drawn into their own little frame buffers which would then immediately be transferred to the display and shown."),(0,r.kt)("h2",d({},{id:"configuring-partial-frame-buffers"}),"Configuring Partial Frame Buffers"),(0,r.kt)("p",null,"There are two steps to configuring TouchGFX for partial frame buffers: Creating a frame buffer allocator object with a memory buffer, and configuring the TouchGFX HAL class to use it. Later we also need to write code to transmit the buffers to the display. The first two steps are typically done in the BoardConfiguration.cpp file."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Creating a frame buffer allocator as a global variable:"),(0,r.kt)("br",null)),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"BoardConfiguration.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp"}),"//2 or more blocks of 10*390 pixels, one pixel is 3 bytes\nManyBlockAllocator<10*390*3, 2, 3> frameBufferAllocator;\n")),(0,r.kt)("p",null,"This frame buffer allocator allocates 2 blocks of each 10 x 390 x 3 bytes = 11.700 bytes."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Configure HAL to use it:"),(0,r.kt)("br",null)),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"BoardConfiguration.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{6-7}","{6-7}":!0}),"void touchgfx_init()\n{\n    HAL& hal = touchgfx_generic_init(dma, display, tc, GUI_DISPLAY_WIDTH,\n                                         GUI_DISPLAY_HEIGHT, 0, 0, 0);\n    hal.setFrameBufferStartAddress((uint16_t*)0, GUI_DISPLAY_BPP, false, false);\n    hal.setFrameBufferAllocator(&frameBufferAllocator);\n    hal.setFrameRefreshStrategy(HAL::REFRESH_STRATEGY_PARTIAL_FRAMEBUFFER);\n   ...\n")),(0,r.kt)("p",null,"With this configuration TouchGFX will allocate small frame buffers and draw the UI in them. What is left now, is to transfer the small frame buffers to the display."),(0,r.kt)("p",null,"Lets first see the position and size of the two frame buffers allocated to draw the small circle updates (second image above):"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Rectangle")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"x")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"y")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"width")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"height")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Pixels")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",d({parentName:"tr"},{align:null}),"Rectangle 1"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"112"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"56"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"22"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"14"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"308 pixels = 924 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",d({parentName:"tr"},{align:null}),"Rectangle 2"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"153"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"42"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"29"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"11"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"319 pixels = 957 bytes")))),(0,r.kt)("p",null,"Both these rectangles are so small, they can fit into the blocks allocated by the frame buffer allocator."),(0,r.kt)("p",null,"In the third image above, we have 3 updated rectangles: The small updates to the circle, and the larger rectangle covering the text:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Rectangle")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"x")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"y")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"width")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"height")),(0,r.kt)("th",d({parentName:"tr"},{align:null}),(0,r.kt)("strong",{parentName:"th"},"Pixels")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",d({parentName:"tr"},{align:null}),"Rectangle 1"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"126"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"51"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"20"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"12"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"240 pixels = 720 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",d({parentName:"tr"},{align:null}),"Rectangle 2"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"165"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"42"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"33"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"8"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"264 pixels = 792 bytes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",d({parentName:"tr"},{align:null}),"Rectangle 3"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"118"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"165"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"154"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"60"),(0,r.kt)("td",d({parentName:"tr"},{align:null}),"9.240 pixels = 27.720 bytes")))),(0,r.kt)("p",null,"Again, the rectangle 1 and 2 are so small, they can fit into the blocks allocated by the frame buffer allocator, but frame buffer 3 is too large. This rectangle is to large and will be split into multiple rectangles that each can fit into the frame buffers (11.700 bytes)."),(0,r.kt)("p",null,"Here we are updating 3 rectangles, but the allocator only has 2 blocks. In that situation, TouchGFX will wait for the first blocks to transferred and then reuse the blocks."),(0,r.kt)("h2",d({},{id:"transferring-frame-buffers-to-the-screen"}),"Transferring Frame Buffers to the Screen"),(0,r.kt)("p",null,"TouchGFX will allocate a frame buffer from the FrameBufferAllocator, when a rectangle needs to be redrawn. After drawing to the buffer TouchGFX will call this method:"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp"}),"void HAL::flushFrameBuffer(const Rect& rect);\n")),(0,r.kt)("p",null,"This function can be overridden in a HAL subclass to transfer the frame buffer to the screen. This special implementation is required for partial framebuffers to work. The following sections will illustrate how to configure this for the STM32G081 and STM32G071 evaluation kits with a SPI displays, and the STM32L4R9Discovery evaluation kit which has a DSI display."),(0,r.kt)("h3",d({},{id:"transferring-frame-buffers-to-the-stm32g081-spi-display"}),"Transferring Frame Buffers to the STM32G081 SPI Display"),(0,r.kt)("p",null,"The STM32G081 evaluation kit has a SPI display. The basic principle is to start a DMA transfer to the display as soon as a block is drawn or when a transfer is completed if a new block is ready to be transferred."),(0,r.kt)("p",null,"First, when a rectangle is drawn, we start a transfer if none is already in progress:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"STM32G0HAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{4-4,10-10}","{4-4,10-10}":!0}),"void STM32G0HAL::flushFrameBuffer(const touchgfx::Rect& rect)\n{\n    HAL::flushFrameBuffer(rect);\n    frameBufferAllocator->markBlockReadyForTransfer();\n    //start transfer if not running already!\n    if (!LCDManager_IsTransmittingData())\n    {\n        touchgfx::Rect r;\n        const uint8_t* pixels = frameBufferAllocator->getBlockForTransfer(r);\n        LCDManager_SendFrameBufferBlockWithPosition((uint8_t*)pixels, r.x, r.y, r.width, r.height);\n    }\n}\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("em",{parentName:"p"},"LCDManager_SendFrameBufferBlockWithPosition")," starts a SPI transfer to the display using DMA. This function is highly dependent on the display and the GPIO configuration. It must be developed by the application programmer. The STM32G0 CubeFW HAL function ",(0,r.kt)("em",{parentName:"p"},"HAL_SPI_Transmit_DMA")," is used to start the DMA."),(0,r.kt)("p",null,"The SPI transfer complete interrupt handler calls a function when the transfer is complete:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"STM32G0HAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{11-11}","{11-11}":!0}),"void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)\n{\n    UNUSED(hspi);\n    LCD_CS_HIGH();\n    isTransmittingData = 0;\n\n    //Change to SPI datasize to 8 bit from 16 bit\n    heval_Spi.Instance->CR2 &= ~(SPI_DATASIZE_16BIT - SPI_DATASIZE_8BIT);\n\n    //signal transfer complete\n    LCDManager_TransferComplete();\n}\n")),(0,r.kt)("p",null,"The LCDManager_TransferComplete functions starts a new transfer. An important piece here is to call ",(0,r.kt)("em",{parentName:"p"},"freeBlockAfterTransfer"),". This will allow TouchGFX to reuse the just transmitted block for a new drawing."),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"STM32G0HAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{3-3,16-16}","{3-3,16-16}":!0}),"void LCDManager_TransferComplete()\n{\n    touchgfx::startNewTransfer();\n}\n\nvoid startNewTransfer()\n{\n    FrameBufferAllocator* fba = HAL::getInstance()->getFrameBufferAllocator();\n    fba->freeBlockAfterTransfer();\n    blockIsTransferred = true;\n\n    if (fba->hasBlockReadyForTransfer())\n    {\n        touchgfx::Rect r;\n        const uint8_t* pixels = fba->getBlockForTransfer(r);\n        LCDManager_SendFrameBufferBlockWithPosition((uint8_t*)pixels, r.x, r.y, r.width, r.height);\n    }\n}\n\n")),(0,r.kt)("h3",d({},{id:"transferring-frame-buffers-to-the-x-nucleo-gfx01m1-spi-display"}),"Transferring Frame Buffers to the X-NUCLEO-GFX01M1 SPI Display"),(0,r.kt)("p",null,'In this section we will discuss the application template for the STM32G071 nucleo board with the X-Nucleo-GFX01M1 expansion board. This expansion board, MB1642B, contains a 2.2" 240x320 SPI display and a 64-Mbit SPI NOR flash.'),(0,r.kt)(n.Z,{imageSource:"/img/development/ui-development/scenarios/lowering-memory-usage-with-partial-framebuffer/g071-with-gfx01m1.webp",width:"400px",mdxType:"Figure"},"Nucleo-G071RB with X-Nucleo-GFX01M1 expansion board"),(0,r.kt)("p",null,"In this application template we use a C++ class from the framework to help managing the partial framebuffer blocks. This makes the code in the application template a little shorter."),(0,r.kt)("p",null,"The application template is build with the TouchGFX Generator. Read more about that ",(0,r.kt)("a",d({parentName:"p"},{href:"../touchgfx-hal-development/touchgfx-generator#display"}),"here")),(0,r.kt)("p",null,"The most important part is the flushFrameBuffer function:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{5-5}","{5-5}":!0}),"void TouchGFXGeneratedHAL::flushFrameBuffer(const touchgfx::Rect& rect)\n{\n    HAL::flushFrameBuffer(rect);\n    // Try transmitting a block\n    PartialFrameBufferManager::tryTransmitBlock();\n}\n")),(0,r.kt)("p",null,"Here we just call the ",(0,r.kt)("em",{parentName:"p"},"PartialFrameBufferManager")," framework class to get the block transmitted."),(0,r.kt)("p",null,"In the TouchGFXGeneratedHAL::endFrame function we call ",(0,r.kt)("em",{parentName:"p"},"PartialFrameBufferManager")," to get any remaining framebuffer blocks transmitted also:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{5-5}","{5-5}":!0}),"void TouchGFXGeneratedHAL::endFrame()\n{\n    // We must guard the next frame until we're done transferring all blocks over our display interface\n    // through either a semaphore if user is running an OS or a simple variable if not\n    PartialFrameBufferManager::transmitRemainingBlocks();\n\n    HAL::endFrame();\n    touchgfx::OSWrappers::signalRenderingDone();\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"PartialFrameBufferManager")," uses three functions to interact with the display driver code. These must be implemented in the Application Template:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{4-4,12-12,20-20}","{4-4,12-12,20-20}":!0}),"/**\n * Check if a Frame Buffer Block is beeing transmitted.\n */\n__weak int transmitActive()\n{\n    return touchgfxDisplayDriverTransmitActive();\n}\n\n/**\n * Check if a Frame Buffer Block ending at bottom may be sent.\n */\n__weak int shouldTransferBlock(uint16_t bottom)\n{\n    return touchgfxDisplayDriverShouldTransferBlock(bottom);\n}\n\n/**\n * Transmit a Frame Buffer Block.\n */\n__weak void transmitBlock(const uint8_t* pixels, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n    touchgfxDisplayDriverTransmitBlock(pixels, x, y, w, h);\n}\n")),(0,r.kt)("p",null,"The code above just forwards the calls to C functions in the MB1642B driver code."),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"MB1642BDisplayDriver.c"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp"}),"int touchgfxDisplayDriverTransmitActive(void)\n{\n  return IsTransmittingBlock_;\n}\n\nvoid touchgfxDisplayDriverTransmitBlock(const uint8_t* pixels, uint16_t x, uint16_t y, uint16_t w, uint16_t h)\n{\n  Display_Bitmap((uint16_t*)pixels, x, y, w, h);\n}\n")),(0,r.kt)("p",null,"The implementation of this driver code depends highly on the display used. For the MB1642B module this involves two GPIO to control SPI chip select and data/command mode."),(0,r.kt)("p",null,"The transmission state is implemented using a volatile uint8",(0,r.kt)("em",{parentName:"p"},"t variable *IsTransmittingBlock"),"*. This variable is set to 1 when a transmission is started and set to zero in the DMA callback:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"MB1642BDisplayDriver.c"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp"}),"void MB1642BDisplayDriver_DMACallback(void)\n{\n  /* Transfer Complete Interrupt management ***********************************/\n  if ((0U != (DMA1->ISR & (DMA_FLAG_TC1))) && (0U != (hdma_spi1_tx.Instance->CCR & DMA_IT_TC)))\n  {\n    /* Disable the transfer complete and error interrupt */\n    __HAL_DMA_DISABLE_IT(&hdma_spi1_tx, DMA_IT_TE | DMA_IT_TC);\n\n    /* Clear the transfer complete flag */\n    __HAL_DMA_CLEAR_FLAG(&hdma_spi1_tx, DMA_FLAG_TC1);\n\n    IsTransmittingBlock_ = 0;\n\n    ...\n\n    // Signal Transfer Complete to TouchGFX\n    DisplayDriver_TransferCompleteCallback();\n")),(0,r.kt)("p",null,"As we see above, the DMA callback also calls the transfer complete callback. This function is implemented in the generated HAL:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp"}),'extern "C"\nvoid DisplayDriver_TransferCompleteCallback()\n{\n    // After completed transmission start new transfer if blocks are ready.\n    PartialFrameBufferManager::tryTransmitBlockFromIRQ();\n}\n')),(0,r.kt)("p",null,"The call to the ",(0,r.kt)("em",{parentName:"p"},"PartialFrameBufferManager")," here makes it start a new transfer if possible."),(0,r.kt)("h3",d({},{id:"transferring-frame-buffers-on-dsi-display"}),"Transferring Frame Buffers on DSI Display"),(0,r.kt)("p",null,"The STM32L4R9Discovery evaluation kit uses a DSI display. The normal HAL class is called STM32HAL_DSI (located in STM32HAL_DSI.cpp)."),(0,r.kt)("p",null,"We override the HAL::flushFrameBuffer method to notify the FrameBufferAllocator that a block has been drawn:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"STM32HAL_DSI.hpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{3-3}","{3-3}":!0}),"void STM32HAL_DSI::flushFrameBuffer(const Rect& rect)\n{\n    frameBufferAllocator->markBlockReadyForTransfer();\n    HAL::flushFrameBuffer(rect); //call normal implementation\n}\n")),(0,r.kt)("p",null,"The FrameBufferAllocator subclass ManyBlockAllocator will call the global function FrameBufferAllocatorSignalBlockDrawn() when a block is ready for transfer. This method must be implemented in the BSP layer:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"BoardConfiguration.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{5-5}","{5-5}":!0}),"void FrameBufferAllocatorSignalBlockDrawn()\n  {\n    if (!dsiIsTransferring)\n    {\n      sendBlock();\n    }\n  }\n")),(0,r.kt)("p",null,'This function is calling the sendBlock function, unless a transfer is already ongoing on the DSI. For the first block drawn by TouchGFX, this will never be the case, so a transfer is started. If another block drawing is completed while the DSI transfer is still running, the block will be kept in the "ready to transfer state", and drawing will continue in another free block (if available).'),(0,r.kt)("p",null,"When a DSI transfer is completed, we must first free the transferred block, so it can be reused for another rectangle, and then check to see if the next block is ready for transfer. This is all done in the ER interrupt:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"BoardConfiguration.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{8-8,11-11}","{8-8,11-11}":!0}),"__irq void DSI_IRQHandler(void) {\n  if (__HAL_DSI_GET_FLAG(&hdsi, DSI_IT_ER))\n  {\n    // End-of-refresh interrupt. Meaning last DSI transfer is complete\n    __HAL_DSI_CLEAR_FLAG(&hdsi, DSI_IT_ER);\n    if (dsiIsTransferring)\n    {\n      HAL::getInstance()->getFrameBufferAllocator()->freeBlockAfterTransfer();\n      dsiIsTransferring = 0;\n    }\n    sendBlock(); //transfer next block if availble\n  }\n")),(0,r.kt)("p",null,"The function sendBlock is more complicated. Here we configure the LTDC and DSI peripherals to transfer the framebuffer. We also configure the display to put the transferred data into the correct place in the display memory. This part of the code is dependent on the specific display. Check the display datasheet for the command specifications."),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"BoardConfiguration.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{18-18,40-40,51-51}","{18-18,40-40,51-51}":!0}),"static void sendBlock()\n{\n    FrameBufferAllocator* fbAllocator = HAL::getInstance()->getFrameBufferAllocator();\n\n    //Is a block ready for transfer?\n    if (fbAllocator->hasBlockReadyForTransfer())\n    {\n        Rect transfer_rect;\n        const uint8_t* src = fbAllocator->getBlockForTransfer(transfer_rect);\n        dsiIsTransferring = 1;\n\n        //1. Setup LTDC and layer address and dimension\n        //2. Configure display active area\n        //3. Start DSI\n\n        __HAL_DSI_WRAPPER_DISABLE(&hdsi);\n\n        //1: Setup LTDC\n        LTDC_Layer1->CFBAR = (uint32_t)src;\n\n        const uint32_t width = transfer_rect.width;\n        const uint32_t height = transfer_rect.height;\n\n        LTDC->AWCR = ((width + 1) << 16) | (height + 1);\n        LTDC->TWCR = ((width + 1 + 1) << 16) | (height + 1 + 1);\n\n        const uint16_t layer_x0 = 2 + 0;\n        const uint16_t layer_x1 = 2 + width - 1;\n        LTDC_Layer1->WHPCR = (layer_x1 << 16) | layer_x0;\n\n        const uint16_t layer_y0 = 2 + 0;\n        const uint16_t layer_y1 = 2 + height - 1;\n        LTDC_Layer1->WVPCR = (layer_y1 << 16) | layer_y0;\n\n        LTDC_Layer1->CFBLR = ((width * 3) << 16) | (width * 3 + 3);\n        LTDC_Layer1->CFBLNR = height;\n\n        LTDC->SRCR = (uint32_t)LTDC_SRCR_IMR;\n\n        //2: Configure display\n        const int16_t x = transfer_rect.x + 4;\n        const int16_t x2 = transfer_rect.x + 4 + width - 1;\n        uint8_t InitParam1[4] = { (uint8_t)(x >> 8), (uint8_t)(x & 0xFF), (uint8_t)(x2 >> 8), (uint8_t)(x2 & 0xFF)};\n        HAL_DSI_LongWrite(&hdsi, 0, DSI_DCS_LONG_PKT_WRITE, 4, DSI_SET_COLUMN_ADDRESS, InitParam1);\n\n        const int16_t y = transfer_rect.y;\n        const int16_t y2 = transfer_rect.y + height - 1;\n        uint8_t InitParam2[4] = { (uint8_t)(y >> 8), (uint8_t)(y & 0xFF), (uint8_t)(y2 >> 8), (uint8_t)(y2 & 0xFF) };\n        HAL_DSI_LongWrite(&hdsi, 0, DSI_DCS_LONG_PKT_WRITE, 4, DSI_SET_PAGE_ADDRESS, InitParam2);\n\n        //3: Start DSI transfer\n        __HAL_DSI_WRAPPER_ENABLE(&hdsi);\n        HAL_DSI_Refresh(&hdsi);\n    }\n}\n")),(0,r.kt)("h3",d({},{id:"transferring-frame-buffers-on-spi-display"}),"Transferring Frame Buffers on SPI Display"),(0,r.kt)("p",null,"The STM32G081 evaluation kit has a SPI display. The principle for transferring the rectangles to the display is the same as for the DSI, but some details are different."),(0,r.kt)("p",null,"First, when a rectangle is drawn, we start a transfer if none is already in progress:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"STM32G0HAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{4-4,10-10}","{4-4,10-10}":!0}),"void STM32G0HAL::flushFrameBuffer(const touchgfx::Rect& rect)\n{\n    HAL::flushFrameBuffer(rect);\n    frameBufferAllocator->markBlockReadyForTransfer();\n    //start transfer if not running already!\n    if (!LCDManager_IsTransmittingData())\n    {\n        touchgfx::Rect r;\n        const uint8_t* pixels = frameBufferAllocator->getBlockForTransfer(r);\n        LCDManager_SendFrameBufferBlockWithPosition((uint8_t*)pixels, r.x, r.y, r.width, r.height);\n    }\n}\n")),(0,r.kt)("p",null,"The function ",(0,r.kt)("em",{parentName:"p"},"LCDManager_SendFrameBufferBlockWithPosition")," starts a SPI transfer to the display using DMA."),(0,r.kt)("p",null,"The SPI transfer complete handler calls a function when the transfer is complete:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"STM32G0HAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{11-11}","{11-11}":!0}),"void HAL_SPI_TxCpltCallback(SPI_HandleTypeDef *hspi)\n{\n    UNUSED(hspi);\n    LCD_CS_HIGH();\n    isTransmittingData = 0;\n\n    //Change to SPI datasize to 8 bit from 16 bit\n    heval_Spi.Instance->CR2 &= ~(SPI_DATASIZE_16BIT - SPI_DATASIZE_8BIT);\n\n    //signal transfer complete\n    LCDManager_TransferComplete();\n}\n")),(0,r.kt)("p",null,"The LCDManager_TransferComplete functions starts a new transfer:"),(0,r.kt)(l.Z,{mdxType:"CodeHeader"},"STM32G0HAL.cpp"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-cpp",metastring:"{3-3,16-16}","{3-3,16-16}":!0}),"void LCDManager_TransferComplete()\n{\n    touchgfx::startNewTransfer();\n}\n\nvoid startNewTransfer()\n{\n    FrameBufferAllocator* fba = HAL::getInstance()->getFrameBufferAllocator();\n    fba->freeBlockAfterTransfer();\n    blockIsTransferred = true;\n\n    if (fba->hasBlockReadyForTransfer())\n    {\n        touchgfx::Rect r;\n        const uint8_t* pixels = fba->getBlockForTransfer(r);\n        LCDManager_SendFrameBufferBlockWithPosition((uint8_t*)pixels, r.x, r.y, r.width, r.height);\n    }\n}\n\n")),(0,r.kt)("h2",d({},{id:"conclusion"}),"\uacb0\ub860"),(0,r.kt)("p",null,"In this article we saw how the partial frame buffer strategy can help lowering the memory requirements for platforms that have displays with integrated frame buffer memory."),(0,r.kt)("p",null,"The method for configuring and setting up partial framebuffers is the same across all platforms, but the method of sending the content of the blocks to the display varies. We saw how, for an LTDC/DSI based platform (STM32L4R9-DISCO) we were able to reconfigure the LTDC Layer to fit the next block ready for transfer on DSI, while on a platform with no LCD controller (STM32G081) we were able to send the blocks to the display using SPI."))}w.isMDXComponent=!0}}]);